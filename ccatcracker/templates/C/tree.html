{% extends 'base_1.html' %}
{% block title %} Binary Search Tree | Data Structures Tutorial |  {% endblock %}
{% block content %}
<style>
   p {
   display: block;
   margin-top: 1em;
   margin-bottom: 1em;
   margin-left: 0;
   margin-right: 0;
   
   font-size: 17px;
   }
   pre{
   background-color: #e0e0e0;
   border-radius: 10px;
   color: rgba(0,0,0,.9);
   font-family: Consolas,monospace;
   margin-bottom: 10px;
   overflow: auto;
   padding: 10px;
   margin: 0px 0px 10px;
   text-align: left;
   }
   .heading
   {
       color: #008c00;
   }
   .shead
   {
       color: #008c00;
   }
</style>
<!-- Breadcrumb -->
<section id="bc" class="mt-3">
   <div class="container">
      <nav aria-label="breadcrumb">
         <ol class="breadcrumb">
            <li class="breadcrumb-item">
               <a href="{% url 'index' %}">
                    <i class="fas fa-home"></i> Home</a></a>
            </li>
            <li class="breadcrumb-item active"> Data Structure</li>
         </ol>
      </nav>
   </div>
</section>
</div>
<section id="about" class="py-4">
   <div class="container">
      <div class="row">
         <div class="col-md-8">
           
               <h3 style="color:green"> Tree In Data Structure  : </h3> <br>
               <p >

                    A tree whose elements have at most 2 children is called a binary tree. Since each element in a binary tree can have only 2 children, we typically name them the left and right child.
                    <br> <br>
                </p>
               <h4 style="color: black">Copy Below Links And Watch Lectures First :</h4>
               <br>
                <h5 style="color:green">1. Tree In Data Structure  : https://youtu.be/jBDc4Uuif28</h5>
                <h5 style="color:green">2. Tree In Data Structure  : https://youtu.be/bCtmP8pSBF4</h5> 
                <h5 style="color:green">3. Tree In Data Structure  : https://youtu.be/dDjQphXcISc</h5>
                <h5 style="color:green">4. Infix In Data Structure  : https://youtu.be/sw05hkrlJmE</h5>
                <h5 style="color:green">5. Postfix In Data Structure  : https://youtu.be/p4pPawXDh0U</h5>
                
                
                
                <br>
                <br>
                <h3 class="heading">Basic Operations Performed  : </h3>
                <br>

                <p>

                        Insert − Inserts an element in a tree/create a tree.
                        <br> <br>
                        Search − Searches an element in a tree.
                        <br> <br>
                        Preorder Traversal − Traverses a tree in a pre-order manner.
                        <br> <br>
                        Inorder Traversal − Traverses a tree in an in-order manner.
                        <br> <br>
                        Postorder Traversal − Traverses a tree in a post-order manner.
                        <br> <br>
                </p>
                <h3 class="heading">What is Searching? : </h3>
                <p>
                        Searching is the process of finding a given value position in a list of values.
                        <br><br>
                        It decides whether a search key is present in the data or not.
                        <br><br>
                        It is the algorithmic process of finding a particular item in a collection of items.
                        <br><br>
                        It can be done on internal data structure or on external data structure.
                        <br><br>
                </p>

                <h3 class="heading">Types Of Searching : </h3>
                <p>
                        1. Sequential Search  <br> 
                        2. Binary Search <br>
                </p>
                <h3 class="heading">1. Sequential Search  </h3>
                <br>
                <p>
                        Sequential search is also called as Linear Search.                                                                                                                       <br> <br>
                        Sequential search starts at the beginning of the list and checks every element of the list.<br> <br>
                        It is a basic and simple search algorithm.<br> <br>
                        Sequential search compares the element with all the other elements given in the list. If the element is matched, it returns the value index, else it returns -1.<br> <br>
                       
                        Sequential search is applied on the unsorted or unordered list when there are fewer elements in a list.
                        <br><br>
                </p>
                       
                <h3 class="heading">2. Binary Search :</h3>
                <p>
                        Binary Search is used for searching an element in a sorted array.                                               <br> <br>
                        It is a fast search algorithm with run-time complexity of O(log n).<br> <br>
                        Binary search works on the principle of divide and conquer.<br> <br>
                        This searching technique looks for a particular element by comparing the middle most element of the collection.<br> <br>
                        It is useful when there are large number of elements in an array.<br> <br>

                        Binary searching starts with middle element. If the element is equal to the element that we are searching then return true. If the element is less than then move to the right of the list or if the element is greater than then move to the left of the list. Repeat this, till you find an element.
                        <br><br>
                        
                </p>
                <h3 class="heading">Difference Between Linear and Binary Search :</h3>
                <br>
                <p>
                A linear search scans one item at a time, without jumping to any item. In contrast, binary search cuts down your search to half as soon as you find the middle of a sorted list.
                <br> <br>
                In linear search, the worst case complexity is O(n), where binary search making O(log n) comparisons.
                <br> <br>
                Time taken to search elements keep increasing as the number of elements is increased when searching through linear process. But binary search compresses the searching period by dividing the whole array into two half.
                <br> <br>
                Linear search does the sequential access whereas Binary search access data randomly.
                <br> <br>
                Input data needs to be sorted in Binary Search and not in Linear Search.
                <br> <br>
                In linear search, performance is done by equality comparisons. In binary search, performance is done by ordering comparisons.
                <br> <br>
                Binary search is better and quite faster than linear search.
                <br> <br>
                Linear search uses sequential approach. But, binary search implements divide and conquer approach.
                <br> <br>
                Linear search is quick and easy to use, but there is no need for any ordered elements. Where binary search algorithm is tricky, and elements are necessarily arranged in order.
                <br> <br>
                The best case time in linear search is for the first element that is O(1). And the other side O(1) is the middle element in binary search.
                <br> <br>
                Linear search can be implemented in an array as well as in linked list, but binary search can't be implemented directly on linked list.
                <br> <br>
                Binary search is efficient for the larger array. If the amount of data is small, then linear search is preferable because this searching process is fast when data is small.
                <br> <br>
                </p>
                <br>
                <h3 class="heading">Time and Space complexity :</h3>
                 <br>
                 <table width="100%" style="table-layout:fixed;">
                        <thead>
                        <tr>
                        <th>Sorting Algorithm</th>
                        <th colspan="3">Time Complexity</th>
                        <th>Space Complexity</th>
                        </tr>
                        <tr>
                        <th></th>
                        <th>Best Case</th>
                        <th>Average Case</th>
                        <th>Worst Case</th>
                        <th>Worst Case</th>
                        </tr>
                        </thead>
                        <tbody>
                        <tr>
                        <td><strong>Bubble Sort</strong></td>
                        <td><strong>Ω(N)</strong></td>
                        <td><strong>Θ(N<sup>2</sup>)</strong></td>
                        <td><strong>O(N<sup>2</sup>)</strong></td>
                        <td><strong>O(1)</strong></td>
                        </tr>
                        <tr>
                        <td><strong>Selection Sort</strong></td>
                        <td><strong>Ω(N<sup>2</sup>)</strong></td>
                        <td><strong>Θ(N<sup>2</sup>)</strong></td>
                        <td><strong>O(N<sup>2</sup>)</strong></td>
                        <td><strong>O(1)</strong></td>
                        </tr>
                        <tr>
                        <td><strong>Insertion Sort</strong></td>
                        <td><strong>Ω(N)</strong></td>
                        <td><strong>Θ(N<sup>2</sup>)</strong></td>
                        <td><strong>O(N<sup>2</sup>)</strong></td>
                        <td><strong>O(1)</strong></td>
                        </tr>
                        <tr>
                        <td><strong>Merge Sort</strong></td>
                        <td><strong>Ω(N log N)</strong></td>
                        <td><strong>Θ(N log N)</strong></td>
                        <td><strong>O(N log N)</strong></td>
                        <td><strong>O(N)</strong></td>
                        </tr>
                        <tr>
                        <td><strong>Heap Sort</strong></td>
                        <td><strong>Ω(N log N)</strong></td>
                        <td><strong>Θ(N log N)</strong></td>
                        <td><strong>O(N log N)</strong></td>
                        <td><strong>O(1)</strong></td>
                        </tr>
                        <tr>
                        <td><strong>Quick Sort</strong></td>
                        <td><strong>Ω(N log N)</strong></td>
                        <td><strong>Θ(N log N)</strong></td>
                        <td><strong>O(N<sup>2</sup>)</strong></td>
                        <td><strong>O(N log N)</strong></td>
                        </tr>
                        <tr>
                        <td><strong>Radix Sort</strong></td>
                        <td><strong>Ω(N k)</strong></td>
                        <td><strong>Θ(N k)</strong></td>
                        <td><strong>O(N k)</strong></td>
                        <td><strong>O(N + k)</strong></td>
                        </tr>
                        <tr>
                        <td><strong>Count Sort</strong></td>
                        <td><strong>Ω(N + k)</strong></td>
                        <td><strong>Θ(N + k)</strong></td>
                        <td><strong>O(N + k)</strong></td>
                        <td><strong>O(k)</strong></td>
                        </tr>
                        <tr>
                        <td><strong>Bucket Sort</strong></td>
                        <td><strong>Ω(N + k)</strong></td>
                        <td><strong>Θ(N + k)</strong></td>
                        <td><strong>O(N<sup>2</sup>)</strong></td>
                        <td><strong>O(N)</strong></td>
                        </tr>
                        </tbody>
                        </table>
                        <br> <br>
                    </p>
                       
               <h4 style="color: brown">Note : In whatever condition dont forget above chart read 100 time because 2,3 fix question on above chart in exam . </h4>                         <br>

                <h3 class="heading">Sorting : </h3>
                <p>
                        Sorting is a process of ordering or placing a list of elements from a collection in some kind of order. It is nothing but storage of data in sorted order. Sorting can be done in ascending and descending order. It arranges the data in a sequence which makes searching easier. 
                        <br> <br>

                </p>
                <h3 class="heading">Types of Sorting :</h3>
                <p>
                        1. Bubble Sort     <br>
                        2. Insertion Sort<br>
                        3. Selection Sort<br>
                        4. Quick Sort<br>
                        5. Heap Sort<br>
                </p>
                <br>
                <h3 class="heading">1. Bubble Sort  :</h3>
                <p>

                    Bubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in wrong order.
                    <br> <br>
                    Keep in mind following points :  <br> <br>

                    Worst and Average Case Time Complexity: O(n*n). Worst case occurs when array is reverse sorted.
                    <br> <br>
                    Best Case Time Complexity: O(n). Best case occurs when array is already sorted.
                    <br> <br>
                    Auxiliary Space: O(1)
                    <br> <br>
                    Boundary Cases: Bubble sort takes minimum time (Order of n) when elements are already sorted.
                    <br> <br>
                    Sorting In Place: Yes
                    <br> <br>
                    Stable: Yes
                  
                </p>

                <br>
                <h3 class="heading">2. Insertion Sort :</h3><br>
                Insertion sort is a simple sorting algorithm that works the way we sort playing cards in our hands.
                <br> <br>
                Time Complexity: O(n*2)
                <br> <br>
                Auxiliary Space: O(1)
                <br> <br>
                Boundary Cases: Insertion sort takes maximum time to sort if elements are sorted in reverse order. And it takes minimum time (Order of n) when elements are already sorted.
                <br> <br>
                Algorithmic Paradigm: Incremental Approach
                <br> <br>
                Sorting In Place: Yes
                <br> <br>
                Stable: Yes
                <br> <br>
                Insertion sort is used when number of elements is small. It can also be useful when input array is almost sorted, only few elements are misplaced in complete big array.
                <br>
            </p> <br>
            <h3 class="heading">3.  Selection Sort :</h3>

            <p>
                    <br>
                    he selection sort algorithm sorts an array by repeatedly finding the minimum element (considering ascending order) from unsorted part and putting it at the beginning.
                    <br>
                    <br>
                    Time Complexity: O(n2) as there are two nested loops.
                    <br> <br>
                    Auxiliary Space: O(1) <br> <br>
                    The good thing about selection sort is it never makes more than O(n) swaps and can be useful when memory write is a costly operation.
            </p>
            <h3 class="heading">4. Quick Sort :</h3><br>
            <p>
                    Like Merge Sort, QuickSort is a Divide and Conquer algorithm. It picks an element as pivot and partitions the given array around the picked pivot. There are many different versions of quickSort that pick pivot in different ways.
                    <br> <br>
                    Always pick first element as pivot.                    <br> <br>
                    Always pick last element as pivot (implemented below)<br> <br>
                    Pick a random element as pivot.<br> <br>
                    Pick median as pivot.<br> <br>
                   
            </p>
           
            <h3 class="heading">5. Heap Sort : </h3> <br>
            <p>
                    Heap sort is a comparison based sorting technique based on Binary Heap data structure. It is similar to selection sort where we first find the maximum element and place the maximum element at the end. We repeat the same process for remaining element.
                    <br> <br>
                    Heap sort is an in-place algorithm. <br> <br>
                  

                    Time Complexity: Time complexity of heapify is O(Logn). Time complexity of createAndBuildHeap() is O(n) and overall time complexity of Heap Sort is O(nLogn).
            </p>


              <h5 class="shead">Note : This page material is very very important almost 5,6 questions 100 % will come from all these topics
                  . so dont miss anything . <br>
                we will cover lots of objective question in our question program so keep practise . <br>
                prefix Postfix infix on this topic fix 2,3 mathematical problems will come . <br>
                On time complexity chart fix 2,3 questions . 
                <br>
                1,2 questions on tree . 

              </h5>
              

    
        <h5 style="color: brown">Note : Please dont skip any videos think like you are in classroom 
                so you cant miss it . this Tutorial are very very great available on internet . Please let me 
                know if you have any doubts 
            </h5>
             <br> <br>
            <a  style="margin-left: 60%"  href="{% url 'ccat_notify' %}" class="btn btn-secondary text-white btn-lg">Back-To-Home</a>
            <br>  <br>

        </div>
      </div>
   </div>
</section>
</div>
{% endblock %}